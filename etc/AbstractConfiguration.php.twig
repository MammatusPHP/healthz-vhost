<?php declare(strict_types=1);

// phpcs:disable
namespace Mammatus\Http\Server\Generated;

use Mammatus\Http\Server\Middleware\UnformattedContent;
use Mammatus\Http\Server\Web\Server;
use Psr\Container\ContainerInterface;
use Psr\Http\Message\ServerRequestInterface;
use Psr\Log\LoggerInterface;
use React\EventLoop\LoopInterface;
use React\Http\Middleware\LimitConcurrentRequestsMiddleware;
use React\Http\Server as HttpServer;
use React\Promise\PromiseInterface;
use ReactInspector\HttpMiddleware\MiddlewareCollector;
use ReactParallel\EventLoop\EventLoopBridge;
use ReactParallel\Logger\Logger;
use ReactParallel\Pool\Infinite\Infinite;
use ReactParallel\Pool\Worker\Worker as WorkerPool;
use ReactParallel\Streams\RecvObservable;
use ReactParallel\Streams\SingleRecv;
use WyriHaximus\PSR3\CallableThrowableLogger\CallableThrowableLogger;
use function React\Promise\resolve;
use function WyriHaximus\iteratorOrArrayToArray;

/**
 * This class is generated by mammatus/http-server
 */
abstract class AbstractConfiguration
{
    private bool $initialized = false;
    private Server $server_healtz;

    abstract protected function middleware(): iterable;

    final protected function initialize(LoopInterface $loop, LoggerInterface $logger, ContainerInterface $container)
    {
        $threadPool = new Infinite($loop, $container->get(EventLoopBridge::class), 13);
        $channelLogger = $container->get(Logger::class);
        {% for server in servers %}
        $workerPool_{{ server.vhost().name() }}    = new WorkerPool(
            $loop,
            $container->get(EventLoopBridge::class),
            $threadPool,
            new WorkerFactory_{{ server.vhost().name() }}($channelLogger),
            (int) '13'
        );
        $http_server_{{ server.vhost().name() }} = new HttpServer($loop, ...array_merge(
                iteratorOrArrayToArray($this->middleware()),
                [
                    new LimitConcurrentRequestsMiddleware(PHP_INT_MAX),
                    new MiddlewareCollector('{{ server.vhost().name() }}'),
                    static function (ServerRequestInterface $request, callable $next): PromiseInterface {
                        return resolve($next($request->withAttribute('vhost', '{{ server.vhost().name() }}')));
                    },
                    {% if server.hasWebroot() %}
                    new WebrootPreloadMiddleware(
                        '{{ server.webroot() }}',
                        new ContextLogger($logger, ['section' => 'webroot'], 'webroot'),
                        new ArrayCache(), // TODO: Add support for other cache storages
                    )
                    {% endif %}
                    new UnformattedContent(),
                    static function(ServerRequestInterface $request) use ($workerPool_{{ server.vhost().name() }}): PromiseInterface
                    {
                        return $workerPool_{{ server.vhost().name() }}->perform(new \Mammatus\Http\Server\Middleware\Work(new \Mammatus\Http\Server\Middleware\Request($request)));
                    }
                ]
            )
        );
        $http_server_{{ server.vhost().name() }}->on('error', CallableThrowableLogger::create($logger));
        $this->server_{{ server.vhost().name() }} = new Server(
            '{{ server.vhost().name() }}',
            '0.0.0.0:{{ server.vhost().port() }}',
            $http_server_{{ server.vhost().name() }},
        );
        {% endfor %}

        $this->initialized = true;
    }


    /**
     * @return iterable<Server>
     */
    public function servers(): iterable
    {
        if ($this->initialized === false) {
            throw new \Exception('no init yet');
        }

        {% for server in servers %}
        yield '{{ server.vhost().name() }}' => $this->server_{{ server.vhost().name() }};
        {% endfor %}
    }
}
// phpcs:enable
